{"ast":null,"code":"import { getScrollbarWidth } from '../scroll.js';\nimport { client } from '../../plugins/Platform.js';\nlet vpLeft, vpTop;\nexport function validatePosition(pos) {\n  const parts = pos.split(' ');\n  if (parts.length !== 2) {\n    return false;\n  }\n  if (['top', 'center', 'bottom'].includes(parts[0]) !== true) {\n    console.error('Anchor/Self position must start with one of top/center/bottom');\n    return false;\n  }\n  if (['left', 'middle', 'right', 'start', 'end'].includes(parts[1]) !== true) {\n    console.error('Anchor/Self position must end with one of left/middle/right/start/end');\n    return false;\n  }\n  return true;\n}\nexport function validateOffset(val) {\n  if (!val) {\n    return true;\n  }\n  if (val.length !== 2) {\n    return false;\n  }\n  if (typeof val[0] !== 'number' || typeof val[1] !== 'number') {\n    return false;\n  }\n  return true;\n}\nconst horizontalPos = {\n  'start#ltr': 'left',\n  'start#rtl': 'right',\n  'end#ltr': 'right',\n  'end#rtl': 'left'\n};\n['left', 'middle', 'right'].forEach(pos => {\n  horizontalPos[`${pos}#ltr`] = pos;\n  horizontalPos[`${pos}#rtl`] = pos;\n});\nexport function parsePosition(pos, rtl) {\n  const parts = pos.split(' ');\n  return {\n    vertical: parts[0],\n    horizontal: horizontalPos[`${parts[1]}#${rtl === true ? 'rtl' : 'ltr'}`]\n  };\n}\nexport function getAnchorProps(el, offset) {\n  let {\n    top,\n    left,\n    right,\n    bottom,\n    width,\n    height\n  } = el.getBoundingClientRect();\n  if (offset !== void 0) {\n    top -= offset[1];\n    left -= offset[0];\n    bottom += offset[1];\n    right += offset[0];\n    width += offset[0];\n    height += offset[1];\n  }\n  return {\n    top,\n    bottom,\n    height,\n    left,\n    right,\n    width,\n    middle: left + (right - left) / 2,\n    center: top + (bottom - top) / 2\n  };\n}\nfunction getAbsoluteAnchorProps(el, absoluteOffset, offset) {\n  let {\n    top,\n    left\n  } = el.getBoundingClientRect();\n  top += absoluteOffset.top;\n  left += absoluteOffset.left;\n  if (offset !== void 0) {\n    top += offset[1];\n    left += offset[0];\n  }\n  return {\n    top,\n    bottom: top + 1,\n    height: 1,\n    left,\n    right: left + 1,\n    width: 1,\n    middle: left,\n    center: top\n  };\n}\nfunction getTargetProps(width, height) {\n  return {\n    top: 0,\n    center: height / 2,\n    bottom: height,\n    left: 0,\n    middle: width / 2,\n    right: width\n  };\n}\nfunction getTopLeftProps(anchorProps, targetProps, anchorOrigin, selfOrigin) {\n  return {\n    top: anchorProps[anchorOrigin.vertical] - targetProps[selfOrigin.vertical],\n    left: anchorProps[anchorOrigin.horizontal] - targetProps[selfOrigin.horizontal]\n  };\n}\nexport function setPosition(cfg, retryNumber = 0) {\n  if (cfg.targetEl === null || cfg.anchorEl === null || retryNumber > 5 // we should try only a few times\n  ) {\n    return;\n  }\n\n  // some browsers report zero height or width because\n  // we are trying too early to get these dimensions\n  if (cfg.targetEl.offsetHeight === 0 || cfg.targetEl.offsetWidth === 0) {\n    setTimeout(() => {\n      setPosition(cfg, retryNumber + 1);\n    }, 10);\n    return;\n  }\n  const {\n    targetEl,\n    offset,\n    anchorEl,\n    anchorOrigin,\n    selfOrigin,\n    absoluteOffset,\n    fit,\n    cover,\n    maxHeight,\n    maxWidth\n  } = cfg;\n  if (client.is.ios === true && window.visualViewport !== void 0) {\n    // uses the q-position-engine CSS class\n\n    const el = document.body.style;\n    const {\n      offsetLeft: left,\n      offsetTop: top\n    } = window.visualViewport;\n    if (left !== vpLeft) {\n      el.setProperty('--q-pe-left', left + 'px');\n      vpLeft = left;\n    }\n    if (top !== vpTop) {\n      el.setProperty('--q-pe-top', top + 'px');\n      vpTop = top;\n    }\n  }\n\n  // scroll position might change\n  // if max-height/-width changes, so we\n  // need to restore it after we calculate\n  // the new positioning\n  const {\n    scrollLeft,\n    scrollTop\n  } = targetEl;\n  const anchorProps = absoluteOffset === void 0 ? getAnchorProps(anchorEl, cover === true ? [0, 0] : offset) : getAbsoluteAnchorProps(anchorEl, absoluteOffset, offset);\n\n  // we \"reset\" the critical CSS properties\n  // so we can take an accurate measurement\n  Object.assign(targetEl.style, {\n    top: 0,\n    left: 0,\n    minWidth: null,\n    minHeight: null,\n    maxWidth: maxWidth || '100vw',\n    maxHeight: maxHeight || '100vh',\n    visibility: 'visible'\n  });\n  const {\n    offsetWidth: origElWidth,\n    offsetHeight: origElHeight\n  } = targetEl;\n  const {\n    elWidth,\n    elHeight\n  } = fit === true || cover === true ? {\n    elWidth: Math.max(anchorProps.width, origElWidth),\n    elHeight: cover === true ? Math.max(anchorProps.height, origElHeight) : origElHeight\n  } : {\n    elWidth: origElWidth,\n    elHeight: origElHeight\n  };\n  let elStyle = {\n    maxWidth,\n    maxHeight\n  };\n  if (fit === true || cover === true) {\n    elStyle.minWidth = anchorProps.width + 'px';\n    if (cover === true) {\n      elStyle.minHeight = anchorProps.height + 'px';\n    }\n  }\n  Object.assign(targetEl.style, elStyle);\n  const targetProps = getTargetProps(elWidth, elHeight);\n  let props = getTopLeftProps(anchorProps, targetProps, anchorOrigin, selfOrigin);\n  if (absoluteOffset === void 0 || offset === void 0) {\n    applyBoundaries(props, anchorProps, targetProps, anchorOrigin, selfOrigin);\n  } else {\n    // we have touch position or context menu with offset\n    const {\n      top,\n      left\n    } = props; // cache initial values\n\n    // apply initial boundaries\n    applyBoundaries(props, anchorProps, targetProps, anchorOrigin, selfOrigin);\n    let hasChanged = false;\n\n    // did it flip vertically?\n    if (props.top !== top) {\n      hasChanged = true;\n      const offsetY = 2 * offset[1];\n      anchorProps.center = anchorProps.top -= offsetY;\n      anchorProps.bottom -= offsetY + 2;\n    }\n\n    // did it flip horizontally?\n    if (props.left !== left) {\n      hasChanged = true;\n      const offsetX = 2 * offset[0];\n      anchorProps.middle = anchorProps.left -= offsetX;\n      anchorProps.right -= offsetX + 2;\n    }\n    if (hasChanged === true) {\n      // re-calculate props with the new anchor\n      props = getTopLeftProps(anchorProps, targetProps, anchorOrigin, selfOrigin);\n\n      // and re-apply boundaries\n      applyBoundaries(props, anchorProps, targetProps, anchorOrigin, selfOrigin);\n    }\n  }\n  elStyle = {\n    top: props.top + 'px',\n    left: props.left + 'px'\n  };\n  if (props.maxHeight !== void 0) {\n    elStyle.maxHeight = props.maxHeight + 'px';\n    if (anchorProps.height > props.maxHeight) {\n      elStyle.minHeight = elStyle.maxHeight;\n    }\n  }\n  if (props.maxWidth !== void 0) {\n    elStyle.maxWidth = props.maxWidth + 'px';\n    if (anchorProps.width > props.maxWidth) {\n      elStyle.minWidth = elStyle.maxWidth;\n    }\n  }\n  Object.assign(targetEl.style, elStyle);\n\n  // restore scroll position\n  if (targetEl.scrollTop !== scrollTop) {\n    targetEl.scrollTop = scrollTop;\n  }\n  if (targetEl.scrollLeft !== scrollLeft) {\n    targetEl.scrollLeft = scrollLeft;\n  }\n}\nfunction applyBoundaries(props, anchorProps, targetProps, anchorOrigin, selfOrigin) {\n  const currentHeight = targetProps.bottom,\n    currentWidth = targetProps.right,\n    margin = getScrollbarWidth(),\n    innerHeight = window.innerHeight - margin,\n    innerWidth = document.body.clientWidth;\n  if (props.top < 0 || props.top + currentHeight > innerHeight) {\n    if (selfOrigin.vertical === 'center') {\n      props.top = anchorProps[anchorOrigin.vertical] > innerHeight / 2 ? Math.max(0, innerHeight - currentHeight) : 0;\n      props.maxHeight = Math.min(currentHeight, innerHeight);\n    } else if (anchorProps[anchorOrigin.vertical] > innerHeight / 2) {\n      const anchorY = Math.min(innerHeight, anchorOrigin.vertical === 'center' ? anchorProps.center : anchorOrigin.vertical === selfOrigin.vertical ? anchorProps.bottom : anchorProps.top);\n      props.maxHeight = Math.min(currentHeight, anchorY);\n      props.top = Math.max(0, anchorY - currentHeight);\n    } else {\n      props.top = Math.max(0, anchorOrigin.vertical === 'center' ? anchorProps.center : anchorOrigin.vertical === selfOrigin.vertical ? anchorProps.top : anchorProps.bottom);\n      props.maxHeight = Math.min(currentHeight, innerHeight - props.top);\n    }\n  }\n  if (props.left < 0 || props.left + currentWidth > innerWidth) {\n    props.maxWidth = Math.min(currentWidth, innerWidth);\n    if (selfOrigin.horizontal === 'middle') {\n      props.left = anchorProps[anchorOrigin.horizontal] > innerWidth / 2 ? Math.max(0, innerWidth - currentWidth) : 0;\n    } else if (anchorProps[anchorOrigin.horizontal] > innerWidth / 2) {\n      const anchorX = Math.min(innerWidth, anchorOrigin.horizontal === 'middle' ? anchorProps.middle : anchorOrigin.horizontal === selfOrigin.horizontal ? anchorProps.right : anchorProps.left);\n      props.maxWidth = Math.min(currentWidth, anchorX);\n      props.left = Math.max(0, anchorX - props.maxWidth);\n    } else {\n      props.left = Math.max(0, anchorOrigin.horizontal === 'middle' ? anchorProps.middle : anchorOrigin.horizontal === selfOrigin.horizontal ? anchorProps.left : anchorProps.right);\n      props.maxWidth = Math.min(currentWidth, innerWidth - props.left);\n    }\n  }\n}","map":{"version":3,"names":["getScrollbarWidth","client","vpLeft","vpTop","validatePosition","pos","parts","split","length","includes","console","error","validateOffset","val","horizontalPos","forEach","parsePosition","rtl","vertical","horizontal","getAnchorProps","el","offset","top","left","right","bottom","width","height","getBoundingClientRect","middle","center","getAbsoluteAnchorProps","absoluteOffset","getTargetProps","getTopLeftProps","anchorProps","targetProps","anchorOrigin","selfOrigin","setPosition","cfg","retryNumber","targetEl","anchorEl","offsetHeight","offsetWidth","setTimeout","fit","cover","maxHeight","maxWidth","is","ios","window","visualViewport","document","body","style","offsetLeft","offsetTop","setProperty","scrollLeft","scrollTop","Object","assign","minWidth","minHeight","visibility","origElWidth","origElHeight","elWidth","elHeight","Math","max","elStyle","props","applyBoundaries","hasChanged","offsetY","offsetX","currentHeight","currentWidth","margin","innerHeight","innerWidth","clientWidth","min","anchorY","anchorX"],"sources":["C:/Users/PC01/Documents/Desafio_Eliezer_Embracon/front_end/desafio/node_modules/quasar/src/utils/private/position-engine.js"],"sourcesContent":["import { getScrollbarWidth } from '../scroll.js'\nimport { client } from '../../plugins/Platform.js'\n\nlet vpLeft, vpTop\n\nexport function validatePosition (pos) {\n  const parts = pos.split(' ')\n  if (parts.length !== 2) {\n    return false\n  }\n  if ([ 'top', 'center', 'bottom' ].includes(parts[ 0 ]) !== true) {\n    console.error('Anchor/Self position must start with one of top/center/bottom')\n    return false\n  }\n  if ([ 'left', 'middle', 'right', 'start', 'end' ].includes(parts[ 1 ]) !== true) {\n    console.error('Anchor/Self position must end with one of left/middle/right/start/end')\n    return false\n  }\n  return true\n}\n\nexport function validateOffset (val) {\n  if (!val) { return true }\n  if (val.length !== 2) { return false }\n  if (typeof val[ 0 ] !== 'number' || typeof val[ 1 ] !== 'number') {\n    return false\n  }\n  return true\n}\n\nconst horizontalPos = {\n  'start#ltr': 'left',\n  'start#rtl': 'right',\n  'end#ltr': 'right',\n  'end#rtl': 'left'\n}\n\n;[ 'left', 'middle', 'right' ].forEach(pos => {\n  horizontalPos[ `${ pos }#ltr` ] = pos\n  horizontalPos[ `${ pos }#rtl` ] = pos\n})\n\nexport function parsePosition (pos, rtl) {\n  const parts = pos.split(' ')\n  return {\n    vertical: parts[ 0 ],\n    horizontal: horizontalPos[ `${ parts[ 1 ] }#${ rtl === true ? 'rtl' : 'ltr' }` ]\n  }\n}\n\nexport function getAnchorProps (el, offset) {\n  let { top, left, right, bottom, width, height } = el.getBoundingClientRect()\n\n  if (offset !== void 0) {\n    top -= offset[ 1 ]\n    left -= offset[ 0 ]\n    bottom += offset[ 1 ]\n    right += offset[ 0 ]\n\n    width += offset[ 0 ]\n    height += offset[ 1 ]\n  }\n\n  return {\n    top, bottom, height,\n    left, right, width,\n    middle: left + (right - left) / 2,\n    center: top + (bottom - top) / 2\n  }\n}\n\nfunction getAbsoluteAnchorProps (el, absoluteOffset, offset) {\n  let { top, left } = el.getBoundingClientRect()\n\n  top += absoluteOffset.top\n  left += absoluteOffset.left\n\n  if (offset !== void 0) {\n    top += offset[ 1 ]\n    left += offset[ 0 ]\n  }\n\n  return {\n    top, bottom: top + 1, height: 1,\n    left, right: left + 1, width: 1,\n    middle: left,\n    center: top\n  }\n}\n\nfunction getTargetProps (width, height) {\n  return {\n    top: 0,\n    center: height / 2,\n    bottom: height,\n    left: 0,\n    middle: width / 2,\n    right: width\n  }\n}\n\nfunction getTopLeftProps (anchorProps, targetProps, anchorOrigin, selfOrigin) {\n  return {\n    top: anchorProps[ anchorOrigin.vertical ] - targetProps[ selfOrigin.vertical ],\n    left: anchorProps[ anchorOrigin.horizontal ] - targetProps[ selfOrigin.horizontal ]\n  }\n}\n\nexport function setPosition (cfg, retryNumber = 0) {\n  if (\n    cfg.targetEl === null\n    || cfg.anchorEl === null\n    || retryNumber > 5 // we should try only a few times\n  ) {\n    return\n  }\n\n  // some browsers report zero height or width because\n  // we are trying too early to get these dimensions\n  if (cfg.targetEl.offsetHeight === 0 || cfg.targetEl.offsetWidth === 0) {\n    setTimeout(() => {\n      setPosition(cfg, retryNumber + 1)\n    }, 10)\n    return\n  }\n\n  const {\n    targetEl,\n    offset,\n    anchorEl,\n    anchorOrigin,\n    selfOrigin,\n    absoluteOffset,\n    fit,\n    cover,\n    maxHeight,\n    maxWidth\n  } = cfg\n\n  if (client.is.ios === true && window.visualViewport !== void 0) {\n    // uses the q-position-engine CSS class\n\n    const el = document.body.style\n    const { offsetLeft: left, offsetTop: top } = window.visualViewport\n\n    if (left !== vpLeft) {\n      el.setProperty('--q-pe-left', left + 'px')\n      vpLeft = left\n    }\n    if (top !== vpTop) {\n      el.setProperty('--q-pe-top', top + 'px')\n      vpTop = top\n    }\n  }\n\n  // scroll position might change\n  // if max-height/-width changes, so we\n  // need to restore it after we calculate\n  // the new positioning\n  const { scrollLeft, scrollTop } = targetEl\n\n  const anchorProps = absoluteOffset === void 0\n    ? getAnchorProps(anchorEl, cover === true ? [ 0, 0 ] : offset)\n    : getAbsoluteAnchorProps(anchorEl, absoluteOffset, offset)\n\n  // we \"reset\" the critical CSS properties\n  // so we can take an accurate measurement\n  Object.assign(targetEl.style, {\n    top: 0,\n    left: 0,\n    minWidth: null,\n    minHeight: null,\n    maxWidth: maxWidth || '100vw',\n    maxHeight: maxHeight || '100vh',\n    visibility: 'visible'\n  })\n\n  const { offsetWidth: origElWidth, offsetHeight: origElHeight } = targetEl\n  const { elWidth, elHeight } = fit === true || cover === true\n    ? { elWidth: Math.max(anchorProps.width, origElWidth), elHeight: cover === true ? Math.max(anchorProps.height, origElHeight) : origElHeight }\n    : { elWidth: origElWidth, elHeight: origElHeight }\n\n  let elStyle = { maxWidth, maxHeight }\n\n  if (fit === true || cover === true) {\n    elStyle.minWidth = anchorProps.width + 'px'\n    if (cover === true) {\n      elStyle.minHeight = anchorProps.height + 'px'\n    }\n  }\n\n  Object.assign(targetEl.style, elStyle)\n\n  const targetProps = getTargetProps(elWidth, elHeight)\n  let props = getTopLeftProps(anchorProps, targetProps, anchorOrigin, selfOrigin)\n\n  if (absoluteOffset === void 0 || offset === void 0) {\n    applyBoundaries(props, anchorProps, targetProps, anchorOrigin, selfOrigin)\n  }\n  else { // we have touch position or context menu with offset\n    const { top, left } = props // cache initial values\n\n    // apply initial boundaries\n    applyBoundaries(props, anchorProps, targetProps, anchorOrigin, selfOrigin)\n\n    let hasChanged = false\n\n    // did it flip vertically?\n    if (props.top !== top) {\n      hasChanged = true\n      const offsetY = 2 * offset[ 1 ]\n      anchorProps.center = anchorProps.top -= offsetY\n      anchorProps.bottom -= offsetY + 2\n    }\n\n    // did it flip horizontally?\n    if (props.left !== left) {\n      hasChanged = true\n      const offsetX = 2 * offset[ 0 ]\n      anchorProps.middle = anchorProps.left -= offsetX\n      anchorProps.right -= offsetX + 2\n    }\n\n    if (hasChanged === true) {\n      // re-calculate props with the new anchor\n      props = getTopLeftProps(anchorProps, targetProps, anchorOrigin, selfOrigin)\n\n      // and re-apply boundaries\n      applyBoundaries(props, anchorProps, targetProps, anchorOrigin, selfOrigin)\n    }\n  }\n\n  elStyle = {\n    top: props.top + 'px',\n    left: props.left + 'px'\n  }\n\n  if (props.maxHeight !== void 0) {\n    elStyle.maxHeight = props.maxHeight + 'px'\n\n    if (anchorProps.height > props.maxHeight) {\n      elStyle.minHeight = elStyle.maxHeight\n    }\n  }\n  if (props.maxWidth !== void 0) {\n    elStyle.maxWidth = props.maxWidth + 'px'\n\n    if (anchorProps.width > props.maxWidth) {\n      elStyle.minWidth = elStyle.maxWidth\n    }\n  }\n\n  Object.assign(targetEl.style, elStyle)\n\n  // restore scroll position\n  if (targetEl.scrollTop !== scrollTop) {\n    targetEl.scrollTop = scrollTop\n  }\n  if (targetEl.scrollLeft !== scrollLeft) {\n    targetEl.scrollLeft = scrollLeft\n  }\n}\n\nfunction applyBoundaries (props, anchorProps, targetProps, anchorOrigin, selfOrigin) {\n  const\n    currentHeight = targetProps.bottom,\n    currentWidth = targetProps.right,\n    margin = getScrollbarWidth(),\n    innerHeight = window.innerHeight - margin,\n    innerWidth = document.body.clientWidth\n\n  if (props.top < 0 || props.top + currentHeight > innerHeight) {\n    if (selfOrigin.vertical === 'center') {\n      props.top = anchorProps[ anchorOrigin.vertical ] > innerHeight / 2\n        ? Math.max(0, innerHeight - currentHeight)\n        : 0\n      props.maxHeight = Math.min(currentHeight, innerHeight)\n    }\n    else if (anchorProps[ anchorOrigin.vertical ] > innerHeight / 2) {\n      const anchorY = Math.min(\n        innerHeight,\n        anchorOrigin.vertical === 'center'\n          ? anchorProps.center\n          : (anchorOrigin.vertical === selfOrigin.vertical ? anchorProps.bottom : anchorProps.top)\n      )\n      props.maxHeight = Math.min(currentHeight, anchorY)\n      props.top = Math.max(0, anchorY - currentHeight)\n    }\n    else {\n      props.top = Math.max(0, anchorOrigin.vertical === 'center'\n        ? anchorProps.center\n        : (anchorOrigin.vertical === selfOrigin.vertical ? anchorProps.top : anchorProps.bottom)\n      )\n      props.maxHeight = Math.min(currentHeight, innerHeight - props.top)\n    }\n  }\n\n  if (props.left < 0 || props.left + currentWidth > innerWidth) {\n    props.maxWidth = Math.min(currentWidth, innerWidth)\n    if (selfOrigin.horizontal === 'middle') {\n      props.left = anchorProps[ anchorOrigin.horizontal ] > innerWidth / 2\n        ? Math.max(0, innerWidth - currentWidth)\n        : 0\n    }\n    else if (anchorProps[ anchorOrigin.horizontal ] > innerWidth / 2) {\n      const anchorX = Math.min(\n        innerWidth,\n        anchorOrigin.horizontal === 'middle'\n          ? anchorProps.middle\n          : (anchorOrigin.horizontal === selfOrigin.horizontal ? anchorProps.right : anchorProps.left)\n      )\n      props.maxWidth = Math.min(currentWidth, anchorX)\n      props.left = Math.max(0, anchorX - props.maxWidth)\n    }\n    else {\n      props.left = Math.max(0, anchorOrigin.horizontal === 'middle'\n        ? anchorProps.middle\n        : (anchorOrigin.horizontal === selfOrigin.horizontal ? anchorProps.left : anchorProps.right)\n      )\n      props.maxWidth = Math.min(currentWidth, innerWidth - props.left)\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}